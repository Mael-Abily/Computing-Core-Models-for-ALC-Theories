\documentclass{article}

\usepackage{amsthm}
\newtheorem{proposition}{Proposition}[section]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{example}{Example}[section]
\theoremstyle{remark}
\newtheorem{remark}{Remark}[section]
\newtheorem{lemma}{Lemma}[section]

\setlength{\parskip}{0.5em}

\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{comment}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage[utf8]{inputenc} 		% encodage des caracteres utilise (pour les caracteres accentues) -- non utilise ici.
%\usepackage[latin1]{inputenc} 		% autre encodage
\usepackage[english]{babel}		% pour une mise en forme "anglaise"
\usepackage{amsmath,amssymb,amsthm}	% pour les maths
\usepackage{graphicx}			% pour inclure des graphiques
\usepackage{hyperref}			% si vous souhaitez que les references soient des hyperliens
\usepackage{color}			% pour ajouter des couleurs dans vos textes
\usepackage{todonotes}

\def \N {\mathbb N}	


\title{Implementing the Core Chase for the Description Logic ALC}
\author{MaÃ«l Abily}	


\newcommand{\TodoDavid}[1]{\todo[color=green!40]{#1}}
\newcommand{\TodoJF}[1]{\todo{#1}}

\newcommand{\Vars}{\textbf{Vars}}
\newcommand{\Terms}{\textbf{Terms}}
\newcommand{\Preds}{\textbf{Preds}}
\newcommand{\Csts}{\textbf{Csts}}
\newcommand{\Merge}{\textit{Merge}}
\newcommand{\Depth}{\textit{depth}}
\newcommand{\Appl}{\textbf{appl}}
\newcommand{\father}{\textbf{father}}
\newcommand{\Tree}{\textit{Tree}}
\newcommand{\Fut}{\textbf{Fut}}

\begin{document}
\maketitle						% Genere le titre



\section{Introduction}

An important problem in database is the conjunctive query entailment. This problem can be described in a first order logic background: Given a knowledge base $O = (R,F)$ where $F$ is a set of conjunctive formulas (that are formulas constructed only with conjunction and existential quantification) and $R$ is a set of  rules (that are, if $\vec u$ represents a tuple of variables, formulas of the form $\forall \vec x.\forall \vec y.( A(\vec x,\vec y) \rightarrow \exists \vec z. B(\vec x,\vec z))$), and given a query $Q$ (that is a conjunctive formula), determine if the knowledge base $O$ entails the query $Q$. We usually use reasoning algorithms to answer this problem. We can notice that in practice, a lot of formulas can be express via conjunctive formulas.

\begin{example}
For the knowledge base $O$ composed of the set of conjunctive formulas $F = \{\textit{Father}(\textit{Michel}) \}$ and the set of rules $R= \{\forall x. \textit{Father}(x) \rightarrow \exists y. \textit{IsTheSonOf}(y,x) \}$, and for the query $Q = \exists y. \textit{IsTheSonOf}(y,Michel)$, the knowledge base $O$ entails $Q$.
\end{example}

By definition, a knowledge base $O$ entails a query $Q$ if every  model of $O$ is a model of $Q$. It is not practical because a knowledge base can have an infinite number of model.

To deal with this problem, we can compute an universal model of the knowledge base $O$. That is a model of $O$ that is entailed by all the models of $O$. If a such model $U$ exists, we just need to show that $U$ entails $Q$ to conclude that $O$ entails $Q$. Hence, to solve query entailment, we just have to compute a finite universal model $U$ for a given input knowledge base and look if $U$ entails $Q$.

To compute these models, we can use algorithms called the chase. We will present in this document the oblivious chase, the restricted chase and then the core chase. The last chase is the best in the sense of it terminates if and only if there exists a finite universal model. 

Nevertheless, it is the slowest so it it is never used for practical applications.

Therefore, we will focus on a restricted type of knowledge base $O=(R,F)$ where the set of conjunctive formulas $F$ is ground (that is there is no variable in the formula) and where the rule contained in $R$ are Horn-$\mathcal{ALC}$ axioms. It is an interesting restriction because we can represent the results of the chase by a tree.

We will create a quicker chase, that we called the merge chase, that would produce the same output than the core chase. It is based on the idea that in a tree, there exists a sibling relation between the nodes (that is two nodes are siblings if they have the same father) and we will see that, in some conditions, a sibling of a node can be merged on this node like in the figure below where $y$ is a sibling of $t'$ and is merged on it.


\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]

\draw [white] (17.1,-35.9) circle (3);
\draw (17.1,-35.9) node {$t_0$};
\draw [white] (10.1,-24.1) circle (3);
\draw (10.1,-24.1) node {$t'$};
\draw [white] (24.1,-24.1) circle (3);
\draw (24.1,-24.1) node {$y$};
\draw [white] (24.1,-12.4) circle (3);
\draw (24.1,-12.4) node {$x$};
\draw [white] (10.1,-12.4) circle (3);
\draw (10.1,-12.4) node {$t$};
\draw [white] (30.7,-24.6) circle (3);
\draw [white] (50.4,-24.6) circle (3);
\draw [white] (59.7,-36.8) circle (3);
\draw (59.7,-36.8) node {$t_0$};
\draw [white] (59.7,-25.3) circle (3);
\draw (59.7,-25.3) node {$t'$};
\draw [white] (53.4,-13.2) circle (3);
\draw (53.4,-13.2) node {$t$};
\draw [white] (65.4,-13.2) circle (3);
\draw (65.4,-13.2) node {$x$};
\draw [black] (15.57,-33.32) -- (11.63,-26.68);
\fill [black] (11.63,-26.68) -- (11.61,-27.62) -- (12.47,-27.11);
\draw (14.25,-28.75) node [right] {};
\draw [black] (10.1,-21.1) -- (10.1,-15.4);
\fill [black] (10.1,-15.4) -- (9.6,-16.2) -- (10.6,-16.2);
\draw (10.6,-18.25) node [right] {};
\draw [black] (18.63,-33.32) -- (22.57,-26.68);
\fill [black] (22.57,-26.68) -- (21.73,-27.11) -- (22.59,-27.62);
\draw (21.25,-31.25) node [right] {};
\draw [black] (24.1,-21.1) -- (24.1,-15.4);
\fill [black] (24.1,-15.4) -- (23.6,-16.2) -- (24.6,-16.2);
\draw (24.6,-18.25) node [right] {};
\draw [black] (33.7,-24.6) -- (47.4,-24.6);
\fill [black] (47.4,-24.6) -- (46.6,-24.1) -- (46.6,-25.1);
\draw [black] (59.7,-33.8) -- (59.7,-28.3);
\fill [black] (59.7,-28.3) -- (59.2,-29.1) -- (60.2,-29.1);
\draw (60.2,-31.05) node [right] {};
\draw [black] (58.31,-22.64) -- (54.79,-15.86);
\fill [black] (54.79,-15.86) -- (54.71,-16.8) -- (55.6,-16.34);
\draw (57.24,-18.11) node [right] {};
\draw [black] (60.98,-22.59) -- (64.12,-15.91);
\fill [black] (64.12,-15.91) -- (63.33,-16.42) -- (64.23,-16.85);
\draw (63.26,-20.3) node [right] {};
\end{tikzpicture}
\end{center}

We will then try to extend the merge chase on other type of knowledge bases.

\tableofcontents			

First of all, we will define the usefull notions for this paper and give some well known properties. Then, we will move on our contributions. 

\section{Background}

This section deals with a lot of first order logic notions like interpretations and formulas.

\subsection{Facts}

\subsubsection{Syntax}

We considered a set of variables \Vars\ (often noted $x,y,x_{1},\ldots$), a set of constants \Csts\ (often noted $a,b,c,c_{1},\ldots$), and a set of predicates \Preds\ $(P,Q,R,P_{1},\ldots)$. \Csts, \Vars, and \Preds\ are pairwise disjoint. A \emph{term}  (often noted $t,t_{1},\ldots$) is a variable or a constant. We note \Terms\ the set of terms. We write \emph{$\textit{Ar}(P)$} to denote the arity of the predicate $P$. 

\begin{definition}
If $t_1,\ldots,t_n$ are terms and $P$ is a predicate with $Ar(P) = n$, then $P(t_{1},\ldots,t_{n})$ is an \emph{atom}. The atom $P(t_{1},\ldots,t_{n})$ is \emph{ground} if $t_1,\ldots,t_n$ are constants.
\end{definition}

\begin{definition}
A \emph{factbase} $F$ is an existentially closed conjunction of atoms, that is, a formula that does not contain occurrences of free variables and is of the form $\exists x_{1},\ldots,x_{n}.P_{1}(t_{1}^{1},\ldots,t_{k_{1}}^{1})\land \ldots\land P_{m}(t_{1}^{m},\ldots,t_{k_{m}}^{m})$ where $t_i^j$ are terms and $P_i$ are predicates. A factbase is \emph{ground} if each of its atoms is ground.
\end{definition}

In some articles, the factbases are always considered as ground but in this document, we consider factbases that may not be ground. Consequently, a  boolean conjonctive query will be a factbase, so we will only talk about factbases and not introduce the notion of query.

For convenience, we identify factbases as sets of atoms, which allows us to  use  set  notions  such  as  set inclusion. For example, we identify the factbase $\exists x,x_{1},x_{2},x_{3}. P(x) \land Q(x,a) \land R(x_{1},x_{2},x_{3},b)$ with the set of facts $\{P(x),Q(x,a),R(x_{1},x_{2},x_{3},b)\}$.

For a formula $A$, let \emph{$\Vars(A)$}, \emph{$\Csts(A)$}, and \emph{$\Terms(A)$} be the sets of variables, constants, and terms that occur in $A$, respectively.

\begin{definition}
A factbase $F$ \emph{entails} another factbase $F'$ (often noted $F \models F'$) if each interpretation satisfying $F$ satisfies $F'$.
\end{definition}	

\begin{definition}
A factbase $F$ is equivalent to another factbase $F'$ if $F \models F'$ and $F' \models F$.
\end{definition}

\subsubsection{Homomorphism}

\begin{definition}[Substitution]
A \emph{substitution} $\sigma:X \to \Terms$ is a function where X is a set of variables. For example $\{x \mapsto z, y \mapsto a \}$ is a substitution from $\{x,y\}$ to \Terms. By extension: 
\begin{itemize}
\item if $c \in \Csts$, then $\sigma(c) = c$;
\item if $x \in \Vars \setminus X$, $\sigma(x) = x$;
\item if $f = P(t_1,\ldots,t_n)$ is an atom, then $\sigma(f) = P(\sigma(t_1),\ldots,\sigma(t_n))$; and
\item if $F = \{f_1,\ldots,f_n\}$ is a factbase, then $\sigma(F) = \{\sigma(f_1),\ldots,\sigma(f_n)\}$.
\end{itemize}
\end{definition}

\begin{definition}
For two factbases $F$ and $F'$, a \emph{homomorphism} from $F$ to $F'$ is a substitution $\sigma:\Vars(F) \to \Terms$ where $\sigma(F) \subseteq F'$. Sometimes, we will say that we \emph{map} a variable $x$ to a term $t$ if $\sigma(x)=t$.
\end{definition}

\begin{definition}
For two factbases $F$ and $F'$, an \emph{isomorphism} $h$ from $F$ to $F'$ is a bijective homomorphism where its inverse is a homomorphism from $F'$ to $F$. 
\end{definition}

For the remainder of this paper, we identify sets of facts that are unique up to isomorphism.

%\begin{remark}
%A bijective homomorphism is not necessarily an isomorphism. For example, 
%\begin{align*}
%\sigma:\{R(x)\} &\to \{R(a)\}\\
%x &\mapsto a
%\end{align*}
%is a bijective homomorphism but not an isomorphism.
%\end{remark}



\begin{theorem}[Homomorphism Theorem] \label{hom_thm}
A factbase $F$ \emph{entails} another factbase $Q$ if and only if there exists a homomorphism from $Q$ to $F$.
\end{theorem}

The previous theorem has been proved in (\cite{base},theorem 6.2.3).

\begin{example}
The factbase $F = \{P(b,a),A(x)\}$ entails the factbase $Q = \{P(x,a),P(y,z)\}$ due to the homomorphism $\{x \mapsto b, y \mapsto b, z \mapsto a \}$.
\end{example}




%\begin{proof} The size of the problem is $\textit{card}(\Terms(F))+\textit{card}(\Terms(Q))$.
%\begin{itemize}
%\item We choose, as certificate, a homomorphism $\sigma$ from $Q$ to $F$. Firstly, the size of the certificate is $card(var(Q))+ card(terms(F))$ which is polynomial in the size of the problem. Secondly, we can check that the certificate $\sigma$ is a homomorphism in a time which is polynomial in the size of the problem. Therefore, the problem is in NP.  
%\item We make a reduction from 3-COLOR which is known to be NP-complete. Let $G= (V,E)$ be a graph. Let $P$ be a binary predicate. We pose $Q_G = \{P(x,y)/(x,y) \in E\}$ and $K_3 = \{P(c_1,c_2),P(c_1,c_3), P(c_2,c_1),P(c_3,c_1),\\P(c_2,c_3),P(c_3,c_2)\}$. We have to show that $K_3 \models Q_G \Leftrightarrow$ $G$ is 3-colorable. \\
%$\boxed{\Rightarrow}$ Suppose that $K_3 \models Q_G$. There exists a substitution $\sigma:Q_G \to K_3$. We pose: 
%\begin{align*}
%c:V &\to \{c_1,c_2,c_3\}\\
%x &\mapsto \sigma(x)
%\end{align*}
%if $(x,y) \in E$, $P(x,y) \in Q_G$ and so $P(\sigma(x),\sigma(y)) \in K_3$, so $c(x) \neq c(y)$. Therefore, $c$ is a 3-coloration of $G$. \\
%$\boxed{\Leftarrow}$ Conversely, suppose that $G$ is 3-colorable. Let $c:V \to \{c_1,c_2,c_3\}$ be a coloration of $G$. $c$ is a substitution from $Q_G$ to $K_3$. We have to show that $c(Q_G) \subset K_3$. Let $P(x,y)$ be in $Q_G$. We have $(x,y) \in E$, so $c(x) \neq c(y)$. So $P(c(x),c(y)) \in K_3$. Therefore, $c$ is a homomorphism from $Q_G$ to $K_3$ and so $K_3 \models Q_G$.
%\end{itemize}
%\end{proof}




\subsubsection{Core}

For a factbase $F$, let $id_{|F}$ be the substitution mapping each variable in $\Vars(F)$ to itself. And for a subsitution $\sigma$ defined on a factbase $F'$ containing $F$, let $\sigma_{|F}$ be the subsitution $\sigma$ defined only on $\Vars(F')$. In practice, it is better to work on smaller factbases. It leads us to the notions of retracts and cores:

\begin{definition}
A factbase $F'$ is a \emph{retract} of another factbase $F$ if $F' \subseteq F$ and $F' \models F$. A \emph{retractation} from $F$ to $F'$ is a homomorphism $\sigma$ from $F$ to $F'$ such that $\sigma_{|F'}=id_{|F'}$. $F'$ is a \emph{strict retract} of $F$ is $F'$ is a retract of $F$ and $F' \neq F$.
\end{definition}


\begin{proposition} \label{retract}
The factbase $F'$ is a retract of the factbase $F$ if and only if $F' \subseteq F$  and there exists a retractation from $F$ to $F'$.
\end{proposition}

\begin{definition}
If a factbase $F$ does not contain a strict retract, then we say that $F$ is a \emph{core}. A \emph{core} of a factbase $F$ (noted \emph{$\textit{core}(F)$}) is a subset of $F$ that is a core.
\end{definition}

\begin{proposition}
The cores of a finite factbase F are unique up to isomorphism.
\end{proposition}

Hence, we speak of ``the'' core of a factbase.

\begin{example}
$F_1 = \{B(x,y),R(y,z)\}$ is the core of $F = \{B(x,y),R(y,z),B(x,w),R(w,z)\}$ because:
\begin{itemize}
\item $F_1 \subseteq F$;
\item $\{x \mapsto x, y \mapsto y, z \mapsto z, w \mapsto y\}$ is a homomorphism from $F$ to $F_1$, so $F_1$ is a retract of $F$;
\item all strict subsets of $F_1$ are not retracts of $F_1$.
\end{itemize}
Note that $F_2 = \{B(x,w),R(w,z)\}$ is also the core of $F$ and is indeed isomorphic to $F_1$ due to the homomorphism $\{x \mapsto x, y \mapsto w, z \mapsto z\}$ .
\end{example}

%\begin{proposition}
%A factbase $F$ is a core $\Leftrightarrow$ every homomorphism $\sigma$ from $F$ to $F$ is a bijection.
%\end{proposition} 

%\begin{proof}
%We show it by double-implication. \\
%$\boxed{\Leftarrow}$ By contraposition, suppose that the factbase $F$ is not a core: there exists a strict substet $F'$ of $F$ such that $F'$ is a retract of $F$. There exists a homomorphism $\sigma:F \to F$ such that $\sigma(F) = F'$. As $F' \subsetneq F$, $\sigma$ is not surjective, so it is not a bijection. \\
%$\boxed{\Rightarrow}$ Conversely, by contraposition, suppose that there exists a homomorphism $\sigma_1$ that is not bijective. As $F$ is finite, $\sigma_1$ is not surjective. We pose $F' = \sigma_1(F)\subsetneq F$ and we pose $\sigma_2:F \to F$ such that for $x \in F'$, $\sigma_2(x) = x$ and for $x \notin F'$, $\sigma_2(x) = \sigma_1(x)$. We have ${\sigma_2}_{|F'} = id_{|F'}$ and $\sigma_2(F) = F'$. So $\sigma_2$ is a retractation from $F$ to $F'$ and so $F'$ is a strict retract of $F$. Consequently $F$ is not a core.
%\end{proof}



\subsection{Existential Rules}

\subsubsection{Syntax}

\begin{definition}
Let $\vec x$, $\vec y$, and $\vec z$ be some tuples of variables that are pairwise disjoint. An \emph{(existential) rule} $\alpha$ is a first-order formula	of the form $$\forall \vec x.\forall \vec y.( A(\vec x,\vec y) \rightarrow \exists \vec z. B(\vec x,\vec z))$$ where $A$ and $B$ are conjunctions of atoms. We define \emph{$\textit{body}(\alpha)$} = $A$ and \emph{$\textit{head}(\alpha)$} = $B$.
\end{definition}
We omit the universal quantifiers when representing existential rules.
\begin{definition}

A \emph{knowledge base} $O$ is a pair $(R,F)$ where $R$ is a set of existential rules and $F$ is a  ground factbase.
\end{definition}


\subsubsection{Semantics}

\begin{definition}[Entailment]
A factbase $F$ \emph{entails} a rule $\alpha$ if each interpretation satisfying $F$ satisfies $\alpha$. We will note $F \models R$ if $F$ entails each rule of the rule set $R$.
\end{definition}

\begin{theorem}
A factbase $F$ \emph{entails} a rule $\alpha = A(\vec x,\vec y) \rightarrow \exists \vec z. B(\vec x,\vec z)$ if and only if for every homomorphism $\sigma$ from $A$ to $F$, there exists an extension of $\sigma$ that is a homomorphism from $B$ to $F$.
\end{theorem}



\begin{definition}[Model]
A factbase $M$ is a \emph{model} for a knowledge base $O = (R,F)$ if $M \models F$ and $M \models R$.
\end{definition}




\begin{example} We pose $O = (\{\alpha\},F)$ where $\alpha = A(x) \rightarrow \exists z.R(x,z) \wedge A(z)$ and $F = \{A(b)\}$. $U = \{A(b),R(b,x_0)\}\cup \{A(x_i)\mid i \in \N\}\cup \{R(x_i,x_{i+1}) \mid i \in \N\}$ is a universal model of $O$. This knowledge base does not admit finite universal models.
\end{example}

\begin{definition}[Entailment]
A knowledge base $O$ \emph{entails} a factbase B (often noted $O \models B$) if for each model $M$ of $O$, $M \models B$.
\end{definition}

\begin{definition}[Universal model]
A factbase $U$ is an \emph{universal model} for a knowledge base $O = (R,F)$ if for
every model $M$ of $O$, $M \models U$.
\end{definition}


We are interested by universal models because  they can be used to solve fact entailment:

\begin{proposition}
A knowledge base $O$ entails a factbase $B$ if there exists a universal model $U$ for $O$ such that $U \models B$.
\end{proposition}

An important problem that this document has to deal with is: Given a knowledge base $O=(R,F)$ and a factbase $Q$,  does $O \models Q$? It  is  well-known  that  this  problem  is  undecidable (\cite{NP2}, theorem 4). 



\subsection{The Chase}

The process of applying rules on a factbase in order to infer more knowledge is called forward chaining.   Forward  chaining  in  existential  rules  is  usually achieved  via  a  family  of  algorithms  called the  chase. It can be seen as a two-steps process. It first repeatedly applies rules to the set of facts (and eventually computes sometimes the core to supress redundant facts). Then it looks for an answer to the query in this saturated set of facts. This saturated set of facts is a universal model of the knowledge base. The chase is sound and complete; so it must be non-terminating since the problem of entailment is undecidable. To determine how we apply a rule to a set of fact, we introduce the notion of trigger:

\begin{definition}[Trigger]
Let $T$ be a rule set, $\alpha$ be a rule, $\sigma$ be a substitution, and $F$ be a factbase. The tuple $t = (\alpha,\sigma)$ is an \emph{oblivious trigger} for $F$ if: 
\begin{itemize}
\item the domain of $\sigma$ is the set of all variables occurring in $Body(\alpha)$.
\item $\sigma$ is a homomorphism from $Body(\alpha))$ to $F$.
\end{itemize}
In this case, we say that $t$ is \emph{applicable} on $F$.

The tuple $t = (\alpha,\sigma)$ is a \emph{restricted trigger} if $t$ is an oblivious trigger and if for all $\hat \sigma$ that extend $\sigma$ over $\Vars(\textit{Head}(\alpha))$, $\hat \sigma(Head(\alpha)) \nsubseteq F$.
\end{definition} 



Notice that a restricted trigger is also an oblivious trigger. So future definitions that are dealing with oblivious trigger, deal also with restricted trigger. We will therefore use the term trigger to talk about the oblivous and the restricted trigger.

The chase will considere triggers to infer new knowledge from an initial factbase. We explain now how it would apply a trigger, giving rise to the notion of application. 

\begin{definition}[application]
Let $t = (\alpha,\sigma)$ be a trigger of the factbase $F$. $\alpha$ is of the form $A(\vec x,\vec y) \rightarrow \exists \vec z. B(\vec x,\vec z)$. We pose \emph{$\sigma^s$} the substitution that extends $\sigma$ over $\Vars(\textit{Head}(\alpha))$ such that for $y \in \vec z$, $\sigma^s(y) = y_t$ where $y_t$ is a fresh variable unique with respect to the trigger $t$ and the variable $y$.
The factbase $\Appl(F,t)=F \cup \sigma^s(\textit{Head}(\alpha))$ is called an \emph{application} on the factbase $F$ through the trigger $t = (\alpha,\sigma)$. We also say that the trigger $t$ has been applied on $F$.
\end{definition}

\begin{example}. If $\alpha = A(x,y) \rightarrow \exists z.B(x,z)$, $F = \{A(b,c)\}$, and $\sigma = \{x \mapsto b, y \mapsto c \}$ then $(\alpha,\sigma)$ is a restricted trigger for $F$. $\Appl(F,(\alpha,\sigma)) = \{A(b,c),B(b,z_{(\alpha,\sigma)})\}$ where $z_{(\alpha,\sigma)}$ is a fresh variable.
\end{example}

\begin{definition}[Derivation]
An \emph{oblivious derivation} (respectively a \emph{restricted derivation}) from a knowledge base $O= (F,R)$ is a (possibly infinite) sequence $D=F_0,t_1,F_1,t_2,F_2,\ldots$ where $(F_i)_{i \in \N}$ are factbases such that $F_i \subsetneq F_{i+1}$, $t_i$ are oblivious triggers pairwise different (resp. restricted triggers), $F_0 = F$, and $F_{i}= \Appl(F_{i-1},t_i)$ for all $i > 0$.
\end{definition}


\begin{definition}[Fairness]
The oblivious (resp. restricted) derivation $D=F_0,t_1,F_1,t_2,F_2,\ldots$ is \emph{fair} if for every $i$ and every oblivious (resp. restricted) trigger $t$ applicable on $F_i$, there exists $k \geq i$ such that $\Appl(F_{k},t_k) = F_k$ (resp. $t$ is not anymore a restricted trigger on $F_k$).
\end{definition}

A fair derivation garantees that we consider every possible application. An easy way to have a fair derivation is to do a breadth-first search (BFS) on the terms, that is, always apply the oldest triggers before applying other triggers.

We will now define the oblivious and restricted chase, It is defined in \cite{obl_res}.


\begin{definition}
An \emph{oblivious chase} (resp. a restricted chase) for a knowledge base $O= (F,R)$ is a fair oblivious (resp. restricted) derivation $D=F_0,t_1,F_1,t_2,F_2,\ldots$ 
\end{definition}

For every oblivious chase $D = F_0,t_1,F_1,t_2,F_2,\ldots$ for $O$, we have $F_0 \subseteq F_1 \subseteq F_2 \subseteq \ldots$. The result of an oblivious chase does not depend on the derivation $D$ so we can pose \emph{$\textit{Obl(O)}$} = $\cup_{i \in \N}F_i$. We say that the oblivious chase \emph{terminates} if $\textit{Obl(O)}$ is finite.

It is well known that:

\begin{theorem}
For a knowledge base $O$, $\textit{Obl}(O)$ is an universal model of $O$.
\end{theorem}

Consequently, the oblivious chase can be used to solve query entailment.

It is more difficult to define the result of the restricted chase because the result depends on the order of the application of the rules. We define \emph{$\textit{Res(O)}$}$=\{\cup_{i \in \N}F_i \mid D = F_0,t_1,F_1,t_2,F_2,\ldots$ is a retricted chase for $O$ $\}$.

We say that the restricted chase \emph{terminates} if there exists an element in $\textit{Res(O)}$ that is finite.

It is well known that:

\begin{theorem}
For a knowledge base $O$ and for every $U \in \textit{Res}(O)$, $U$ is an universal model of $O$.
\end{theorem}


The oblivious chase  can do a lot of applications that are useless: 
\begin{example}
Suppose that we have the knowledge base $O=(\{\alpha\},F)$ where $\alpha = A(x,y) \rightarrow \exists z.A(y,z) \wedge A(z,y)$ and $F =  \{A(a,b)\}$. An oblivious chase derivation is $F_0,t_1,F_1,t_2,F_2,...$ where $F_0 = F$, $t_1=(\alpha,\{x \mapsto a, y \mapsto b\})$, $F_1=\{A(a,b),A(b,z_{t_1}),A(z_{t_1},b)\}$, $t_2=(\alpha,\{x \mapsto b, y \mapsto z_{t_1}\})$, $F_2=\{A(a,b),A(b,z_{t_1}), \\ A(z_{t_1},b), A(z_{t_1},z_{t_2}), A(z_{t_2},z_{t_1})\}$, \ldots\ It will never terminate because each new atom brings new rule applications. So the oblivious chase does not terminate on $O$ whereas the restricted chase terminates. A restricted chase derivation is $F_0,t_1,F_1$ where $F_0 = F$, $t_1=(\alpha,\{x \mapsto a, y \mapsto b\})$, and $F_1=\{A(a,b)$,$A(b,z_{t_1})$, $A(z_{t_1},b)\}$. This derivation is fair because there is not anymore any restricted trigger for $F_1$. We have $\textit{Res(O)} = F_1$.
\end{example}



The oblivious chase is called this way because it can make naive applications (that is $F_i \vDash F_{i+1}$): in the previous example, $F_1 \models F_2$. The restricted chase is less naive because a restricted trigger is applied only if it really adds information (that is $F_i \nvDash F_{i+1}$).



\begin{theorem}
A knowledge base $O$ entails a factbase $B$ if $\textit{Obl}(O) \models B$ or $\textit{Res}(O) \models B$.
\end{theorem}




\subsubsection{The core chase}

It has been firstly defined in \cite{core_chase}.

\begin{definition}[Core derivation]
A \emph{core derivation} for a knowledge base $O = (R,F)$ is a (possibly infinite) sequence $D = F_0, F_1, F_2, \ldots$ where $F_0 = F$, and for $i >0$, either $F_{i}= \Appl(F_{i-1},t_i)$ is obtained by an application with $t_i$ an oblivious trigger, or $F_i$ is the core of $F_{i-1}$. 
\end{definition} 

\begin{definition}[Fairness]
A core derivation $D=F_0,F_1,F_2,\ldots$ is \emph{fair} if:
\begin{itemize}
\item For every $i$, for every oblivious trigger $t$ applicable on $F_i$, there exists $k > i$ such that $\Appl(F_{k},t) = F_k$ or such that $t$ has been applied on $\Appl(F_{k},t)$.
\item For every $i$, there exists $k \geq i$ such that $F_k$ is a core.

\end{itemize}
\end{definition}

\begin{definition}
A \emph{core chase} for a knowledge base $O= (R,F)$ is a fair core derivation $D=F_0,F_1,F_2,\ldots$ The core chase \emph{terminates} on $O$ if it is a finite core derivation.
\end{definition}

The article \cite{core_chase} has proven that the result of the core chase on a knowledge base is unique up to isomorphism. Therefore, we can define the result of the core chase:

\begin{definition}
If the core chase terminates on $O$ due to the finite core derivation $D=F_0,F_1,F_2,\ldots,F_i$, then we pose \emph{$\textit{C}(O)$} = $F_i$. Otherwise, if the core chase does not terminate,$\textit{C}(O)$ is undefined.
\end{definition}

The following theorem has been proven in (\cite{core_chase}, theorem 7)

\begin{theorem}
The knowledge base $O = (R,F)$ admits a finite universal model if and only if the core chase algorithm terminates on $O$.
\end{theorem}


There exists knowledge bases where the restricted chase does not terminate whereas the core chase terminates. \begin{example}
Suppose that we have the knowledge base $O=(\{\alpha\},F)$ where $\alpha = A(x,y) \rightarrow \exists z.(A(x,x) \wedge A(y,z))$ and $F =  \{A(a,b)\}$. A restricted chase derivation is $F_0,t_1,F_1,t_2,F_2,...$ where 
\begin{itemize}
\item $F_0 = F$,
\item $t_1=(\alpha,\{x \mapsto a, y \mapsto b\})$, 
\item $F_1= F_0 \cup \{A(a,a),A(b,z_{t_1})\}$,
\item $t_2 = (\alpha,\{x \mapsto b, y \mapsto z_{t_1}\})$, 
\item $F_2 = F_1 \cup \{A(b,b),A(z_{t_1},z_{t_2})\}$, 
\item $t_3 = (\alpha,\{x \mapsto z_{t_1}, y \mapsto z_{t_2}\})$, 
\item $F_3 =  F_2 \cup \{A(z_{t_1},z_{t_1}),A(z_{t_2},z_{t_3})\}$,
\item \ldots\
\end{itemize}
It will never terminate because each new atom brings new restricted triggers. 

The core chase terminates on $O$: a core chase derivation is $F_0,F_1,F_2,F_3$ where 
\begin{itemize}
\item $F_0=F$, 
\item $t_1=(\alpha,\{x \mapsto a, y \mapsto b\})$, 
\item $F_1=\Appl(F_0,t_1) =F_0 \cup \{A(a,a),A(b,z_{t_1})\}$, 
\item $t_2 = (\alpha,\{x \mapsto b, y \mapsto z_{t_1}\})$,
\item $F_2 =\Appl(F_1,t_2) =F_1 \cup \{A(b,b),A(z_{t_1},z_{t_2})\}$, 
\item $F_3 = \textit{Core}(F_2)= \{A(a,a),A(a,b),A(b,b)\}$.
\end{itemize} 
There is not anymore any restricted trigger for $F_3$ so the derivation is fair. Consequently the core chase terminates on $O$.

\end{example}

\section{The Merge Chase}

The core chase always terminates when there exists a finite universal model but this core chase is very expensive in time because computing the core of a factbase is hard. Therefore we are presenting a more efficient way to solve this problem in the particular case of Horn-$\mathcal{ALC}$.

\begin{definition}
For a factbase $F$ and a term $t$, we note \emph{$\Preds^1_F(t)$} the set of unary predicates $P$ such that $P(t)\in F$. For two terms $t$ and $t'$, we note \emph{$\Preds^2_F(t,t')$} the set of binary predicates $P$ such that $P(t,t')\in F$.
\end{definition}

In this section, we only consider logical theories with predicates of arity one or two. Hence, we will represent a factbase $F$ by a labelled graph $G = (V,E)$ where $V = \{t \mid t \in \Terms \}$ and $E = \{(t_1,t_2) \mid t_1,t_2 \in \Terms \wedge \Preds_F(t_1,t_2) \neq \emptyset\}$. We label the vertex $v \in V$ by exactly the elements in $\Preds_F^1(v)$ and we label the edge between the terms $t_1$ and $t_2$ by exactly the elements in $\Preds^2_F(t_1,t_2)$. For example with $F = \{A(a), B(a),R(a,b),T(a,b),C(b),R(b,z)\}$: \\

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm, semithick]
  \tikzstyle{every state}=[fill=white,draw=none,text=black]

  \node[state]         (A)                    {$a:A,B$};
  \node[state]         (B) [above right of=A] {$b:C$};
  \node[state]         (C) [right of=A] {$z$};

  \path (A) edge              node {R,T} (B)
        (B) edge              node {R} (C);
\end{tikzpicture}


\subsection{Horn-$\mathcal{ALC}$ }

Horn-$\mathcal{ALC}$ has been introduced in \cite{Horn-ALC}

\begin{definition}[Horn-$\mathcal{ALC}$ axioms]
A \emph{Horn-$\mathcal{ALC}$ axiom} is an existential rule of the form:
\begin{align}
A_1(x) \wedge A_2(x) &\rightarrow B(x) \\
A(x) \wedge R(x,y) &\rightarrow B(y) \\
A(x) &\rightarrow \exists y.R(x,y) \wedge B(y) \\
R(x,y) \wedge B(y) &\rightarrow A(x)
\end{align}

\end{definition}


We fix $O=(R,F)$ a knowledge base for this section where $R$ is a Horn-$\mathcal{ALC}$ rule set.

We can notice that all the variables are introduced by a Horn-$\mathcal{ALC}$ axiom of the form (3).

We will now introduce some notions in order to introduce the new chase and prove that it does what we want.

\begin{definition}
Let $F'$ be a factbase that occurs in a chase derivation of the knowledge base $O$. For a term $t_1$ and a variable $x_2$ appearing in $F'$, we say that $t_1 \prec x_2$ if there exists a restricted trigger $tr = (A(x) \rightarrow \exists y.R(x,y) \wedge B(y), \{x \mapsto t_1\})$ such that $x_2 = y_t$. We write $\prec^+$ to denote the transitive closure of $\prec$.
\end{definition}

Concretely, $t_1 \prec x_2$ if $x_2$ has been introduced by $t_1$ due to a rule of the form (3). Therefore:

\begin{proposition} \label{only one predecessor}
Let $F'$ be a factbase that occurs in a chase derivation of the knowledge base $O$. For every variable $x$, there exists exactly one predecessor for $\prec$.
\end{proposition}

%We can then modify our naming convention:

%\begin{definition}
%Let $t = (\alpha,\sigma)$ be a trigger of the factbase $F$. If $\alpha$ is of the form (1), (2) or (4), we pose $\sigma^s = \sigma$. Otherwise $\alpha$ is of the form $A(x) \rightarrow \exists y.R(x,y) \wedge B(y)$, we pose $\sigma^s = \sigma \cup \{y \mapsto f(\sigma(x))\}$ the substitution that extends $\sigma$ over $\Vars(\textit{Head}(\alpha))$ where $f$ is a fresh symbol that we choose arbitrarily.
%\end{definition} 


\begin{proposition} \label{partial_order}
Let $D = F_0,F_1,\ldots,F_k$ be a chase derivation of the knowledge base $O$. $\prec^+$ is a strict partial order over the set of variables of $F_k$.
\end{proposition}

\begin{proof}
We write $\prec_i$ to denote the relation $\prec$ over the factbase $F_i$. We show by induction on $i$ that $\prec_i^+$ is a strict partial order over the set of variables of $F_i$.

$F_0$ is ground so $\Vars(F_0) = \emptyset$ so the initialisation is true.

Suppose that $\prec^+_i$ is a strict partial order over the set of variables of $F_i$. By construction, $\prec^+_{i+1}$ is transitive over $\Vars(F_{i+1})$. We just have to show that  $\prec^+_{i+1}$ is irreflexive. 

If $F_{i+1}$ is the core of $F_i$, we just take off some facts so $\prec^+_{i+1} \subseteq \prec^+_{i}$. Then, $\prec^+_{i+1}$ is irreflexive.

Otherwise, $F_{i+1}= \Appl(F_{i},t_i)$ with $t_i = (\alpha,\sigma)$ a restricted trigger. 

\begin{itemize}
\item If $\alpha$ is not of the form of the rule $3$, then $\prec^+_{i+1} = \prec^+_{i}$  so $\prec^+_{i+1}$ is also irreflexive by induction hypothesis.
\item Otherwise, $\alpha = A(x) \rightarrow \exists y.R(x,y) \wedge B(y)$ so $F_{i+1} = F_i \cup \{R(\sigma(x),y_{t_i}),B(y_{t_i})\}$ and $\prec_{i+1} =\prec_i \cup (\sigma(x),y_{t_i})$. So $\prec^+_{i+1} = \prec^+_{i} \cup \{(z,y_{t_i}) \mid z = \sigma(x)$ or $z \prec_i^+ \sigma(x)\}$. We can see that $y_{t_i}$ has no successor for the relation $\prec_{i+1}$ so, as $\prec^+_i$ is irreflexive by induction hypothesis, $\prec^+_{i+1}$ is irreflexive.
\end{itemize}


Consequently, $\prec^+_{i+1}$ is a strict partial order over the set of variables of $F_{i+1}$. So the heredity is true.

\end{proof}

We have shown in the proof that the graph induced by $\prec$ does not contain any cycle. Therefore, with the last proposition and Proposition \ref{only one predecessor}: 

\begin{proposition}
Let $F'$ be a factbase that occurs in a chase derivation of the knowledge base $O$. The graph induced by $\prec$ is a forest of trees.
\end{proposition}

We can now define the notion of tree of a term $t$ that is all the facts containing at least one $\prec$-sucessor of $t$:

\begin{definition}[Tree]
Let $F'$ be a factbase that occurs in a chase derivation of the knowledge base $O$. For a term $t$, we pose 
\begin{align*}
\Tree_{F'}&(t) = \{A(t') \mid A(t') \in F' \wedge t' \in \Terms \wedge t \prec^+ t'\} \\
 &\cup \{R(t',x) \mid R(t',x) \in F' \wedge x \in \Vars \wedge t' \in \Terms \wedge (t = t' \vee t \prec^+ t')\}
\end{align*}
\end{definition}


%We can then associate the depth of a variable:
%
%\begin{definition}
%Let $F'$ be a factbase that occurs in a core chase derivation of the knowledge base $O$. We define the \emph{depth} of a term $t$ by induction:
%\begin{itemize}
%\item 
%\end{itemize}
%\end{definition}

We now define the notion of mergeable variable in order to consider an algorithm.

\begin{definition}[Mergeable variable]
Let $F'$ be a factbase that occurs in a chase derivation of the knowledge base $O$. For two terms $t_1$ and $t_2$ such that $t_1 \neq t_2$, $t_1$ is \emph{mergeable} on $t_2$ in $F'$ if:
\begin{itemize}
\item $t_1$ is a variable,
\item $\Preds_{F'}^1(t_1) \subseteq \Preds_{F'}^1(t_2)$,
\item there exists a term $t$ such that
	\begin{itemize}
	\item $\Preds^2_{F'}(t,t_1) \neq \emptyset$, and
	\item $\Preds_{F'}^2(t,t_1) \subseteq \Preds_{F'}^2(t,t_2)$.
	\end{itemize}
\end{itemize}
In this case, we say that $t_1$ is a \emph{mergeable variable}.
\end{definition}

We imposed that $t_1$ is mergeable on $t_2$ only if $t_1$ is a variable because, we will latter map $t_1$ on $t_2$ and it is not possible to map a constant to another term.

%Notice that the definition of siblings can be shorted because, due to the form of the Horn-$\mathcal{ALC}$ axioms, for a term $t$, there exists a unique term $t'$ and a unique binary relation $R$ such that $R(t',t)\in F'$. So we can replace the last condition in the definition about the existence of $t$ by: there exists a term $t$ and a predicate $R$ such that $R(t,t_1) \in F'$ and $R(t,t_2) \in F'$. We write this more complex definition because it works in more general cases.

When $x$ is mergeable on $t$ in $F'$, we want to say that all the triggers applied on $x$ and on the $\prec$-successor of $x$ can be or have already been applied on $t$ and on the $\prec$-successor of $t$. Therefore, all the facts containing $x$ and the $\prec$-successor of $x$ are or will be redundant. But we do not want to supress all these facts because we know that if they are not yet in the tree of $t$, they would be computed so we would like to "recycle" these facts. That is this intuition that leads us to define atomic merging:

\begin{definition}[atomic merging]
For a factbase $F'$, a term $t \in \Terms(F')$, a variable $x\in \Vars(F')$, and a substitution $h$ where $h(x) =t$ and for all $y \neq x, h(y)=y$, if $x$ is mergeable on $t$ in $F'$, then we say that $h(F')$ is the \emph{atomic merging} of $x$ over $t$ in $F'$.
\end{definition}

The following algorithm is the operation that will replace the computation of the core in the core chase. We will show that for a core chase derivation $D =F_0,...,F_k$ of $O$, if we apply our algorithm on $F_k$, then it computes the core of a factbase that could have been produced by continuing the derivation $D$. In this sense, it always computes the core or something better than the core.

\begin{definition}[Merging]
Let $F'$ be a factbase that occurs in a chase derivation of the knowledge base $O$.

\begin{algorithm}[H]
\SetAlgoLined


    Let $\textbf{\Vars}(F') = \{x_1,\ldots, x_n\}$ be such that $(x_i \prec^+ x_j) \Rightarrow i < j$ \;
    \For{$i =1 \text{ to } n$}{
    	\If{$x_i$ is still a variable in $F'$}{
			\For{all term $t$ such that $x_i$ is mergeable on $t$}{
				$F' \leftarrow$ the atomic merging of $x_i$ over $t$ in $F'$.
			}
		}
	}
return $F'$
\caption{Merge($F'$):}


\end{algorithm}
At line 1, we can sort terms like that because, by proposition \ref{partial_order}, $\prec^+$ is a strict partial order over the set of variables of $F'$.
\end{definition}


We will now consider two new chases:

\begin{definition}[derivation]
An \emph{atomic merge derivation} (resp. a \emph{merge derivation}) for a knowledge base $O = (R,F)$ is a (possibly infinite) sequence $D = F_0, F_1, F_2, \ldots$ where $F_0 = F$, and for $i >0$, either $F_{i}= \Appl(F_{i-1},t_i)$ is obtained by an application with $t_i$ an oblivious trigger, or $F_i$ is obtained by an atomic merging of a mergeable variable on a term over $F_{i-1}$ (resp. $F_i = \Merge(F_{i-1})$). 
\end{definition} 

The fairness of an atomic merge derivation will be the same that the fairness of an oblivious derivation and the fairness of a merge derivation will be the same that the fairness of a core derivation.

\begin{definition}
An \emph{atomic merge chase} (resp. a \emph{merge chase})for a knowledge base $O= (R,F)$ is a fair atomic merge derivation (resp. a fair merge derivation) $D=F_0,F_1,F_2,\ldots$
\end{definition}

\begin{definition}
The merge chase \emph{terminates} on $O$ if it is a finite core derivation.
\end{definition}


\begin{example} 
The figure below is an example of merging. We merge the factbase of the left, $x \prec y$ so we first look if $x$ is mergeable on a term and then we look if $y$ is mergeable on a term. The variable $x$ is mergeable on $b$ so we do an atomic merging of $x$ over $b$ that gives us the factbase of the middle. Now, $y$ is mergeable on $c$ so we do an atomic merging of $y$ over $c$ that gives us the factbase of the right.

\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [white] (8.2,-36.8) circle (3);
\draw (8.2,-36.8) node {$a:A$};
\draw [white] (4,-24.6) circle (3);
\draw (4,-24.6) node {$b:\mbox{ }C,D$};
\draw [white] (12.2,-24.6) circle (3);
\draw (12.2,-24.6) node {$x:\mbox{ }C$};
\draw [white] (12.2,-11.2) circle (3);
\draw (12.2,-11.2) node {$y:\mbox{ }E$};
\draw [white] (4,-11.2) circle (3);
\draw (4,-11.2) node {$c:\mbox{ }E$};
\draw [white] (15.5,-24.5) circle (3);
\draw [white] (31.1,-24.5) circle (3);
\draw [white] (33.4,-37.6) circle (3);
\draw (33.4,-37.6) node {$a:\mbox{ }A$};
\draw [white] (33.4,-23.8) circle (3);
\draw (33.4,-23.8) node {$b:\mbox{ }C,D$};
\draw [white] (29.3,-11.2) circle (3);
\draw (29.3,-11.2) node {$c:\mbox{ }E$};
\draw [white] (38.1,-11.2) circle (3);
\draw (38.1,-11.2) node {$y:\mbox{ }E$};
\draw [white] (35.8,-24.5) circle (3);
\draw [white] (50.5,-24.5) circle (3);
\draw [white] (54.6,-37.6) circle (3);
\draw (54.6,-37.6) node {$a:\mbox{ }A$};
\draw [white] (54.6,-24.5) circle (3);
\draw (54.6,-24.5) node {$b:\mbox{ }C,D$};
\draw [white] (54.6,-11.2) circle (3);
\draw (54.6,-11.2) node {$c:E$};
\draw [black] (7.22,-33.96) -- (4.98,-27.44);
\fill [black] (4.98,-27.44) -- (4.76,-28.36) -- (5.71,-28.03);
\draw (6.86,-29.97) node [right] {$S$};
\draw [black] (4,-21.6) -- (4,-14.2);
\fill [black] (4,-14.2) -- (3.5,-15) -- (4.5,-15);
\draw (4.5,-17.9) node [right] {$R$};
\draw [black] (9.13,-33.95) -- (11.27,-27.45);
\fill [black] (11.27,-27.45) -- (10.54,-28.06) -- (11.49,-28.37);
\draw (10.97,-31.39) node [right] {$S$};
\draw [black] (12.2,-21.6) -- (12.2,-14.2);
\fill [black] (12.2,-14.2) -- (11.7,-15) -- (12.7,-15);
\draw (12.7,-17.9) node [right] {$R$};
\draw [red] (18.5,-24.5) -- (28.1,-24.5);
\fill [red] (28.1,-24.5) -- (27.3,-24) -- (27.3,-25);
\draw [black] (33.4,-34.6) -- (33.4,-26.8);
\fill [black] (33.4,-26.8) -- (32.9,-27.6) -- (33.9,-27.6);
\draw (33.9,-30.7) node [right] {$S$};
\draw [black] (32.47,-20.95) -- (30.23,-14.05);
\fill [black] (30.23,-14.05) -- (30,-14.97) -- (30.95,-14.66);
\draw (32.12,-16.82) node [right] {$R$};
\draw [black] (34.45,-20.99) -- (37.05,-14.01);
\fill [black] (37.05,-14.01) -- (36.3,-14.59) -- (37.24,-14.94);
\draw (36.51,-18.31) node [right] {$R$};
\draw [red] (38.8,-24.5) -- (47.5,-24.5);
\fill [red] (47.5,-24.5) -- (46.7,-24) -- (46.7,-25);
\draw [black] (54.6,-34.6) -- (54.6,-27.5);
\fill [black] (54.6,-27.5) -- (54.1,-28.3) -- (55.1,-28.3);
\draw (55.1,-31.05) node [right] {$S$};
\draw [black] (54.6,-21.5) -- (54.6,-14.2);
\fill [black] (54.6,-14.2) -- (54.1,-15) -- (55.1,-15);
\draw (55.1,-17.85) node [right] {$R$};
\end{tikzpicture}
\end{center}

We can notice that the order of variables we choose is really important because an atomic merging can create mergeable variables. In this example, if we treat $y$ before $x$, then at the the moment where we treat $y$, it does not have any term $t$ yet such that $y$ is mergeable on $t$ so at the end, we get the factbase of the middle and we will not have merged every possible mergeable variable.
\end{example}

It is really important that the merging does all the possible atomic merging that it can do. Otherwise, the merge chase may not terminates on some knowledge base whereas there exists a finite universal model (like in the next example) and we want that the merge chase terminates on all knowledge base that admits a finite universal model. 

\begin{example}
We consider in the example that $F= \{R(a,b),R(b,a),A(a),A(b)\}$ and $R = \{\alpha, \beta\}$ where $\alpha = A(x) \rightarrow \exists y.R(x,y) \wedge A(y)$ and $\beta=B(x) \rightarrow A(x)$. We consider the atomic merge chase derivation $F_0 =F,F_1,F_2,...$ We applied to $F_0$ the restricted trigger $t_1 = (\alpha, \{x \mapsto a\})$, we then applied to $F_1$, the restricted trigger $t_2 = (\alpha, \{x \mapsto y_{t_1}\})$ giving rise to the first factbase of the figure below. We then apply the restricted trigger $t_3 = (\beta, \{x \mapsto b\})$ to obtain the factbase $F_3$. At this moment, $y_{t_1}$ is mergeable on $b$ so we do an atomic merging of $y_{t_1}$ over $b$ to get $F_4$ that is the second factbase of the figure. $F_5$ is obtained by the application of the restricted trigger $t_4 = (\alpha, \{x \mapsto y_{t_2}\})$ and is the third factbase of the figure. At this moment, $y_{t_2}$ is mergeable on $a$ so we do an atomic merging of $y_{t_2}$ over $a$ to get $F_6$ that is the last factbase of the figure. We can repeat this infinitely. But $O$ admits a finite universal model: $U = F \cup \{B(b)\}$. So the version of the chase where we consider partial merging is not what we want.


\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [white] (8.5,-24.6) circle (3);
\draw (8.5,-24.6) node {$a:\mbox{ }A$};
\draw [white] (8.5,-33.9) circle (3);
\draw (8.5,-33.9) node {$b:\mbox{ }B$};
\draw [white] (8.5,-14.8) circle (3);
\draw (8.5,-14.8) node {$y_{t_1}:\mbox{ }A$};
\draw [white] (8.5,-5.4) circle (3);
\draw (8.5,-5.4) node {$y_{t_2}:\mbox{ }A$};
\draw [white] (24.7,-33.9) circle (3);
\draw (24.7,-33.9) node {$b:\mbox{ }A,B$};
\draw [white] (24.7,-24) circle (3);
\draw (24.7,-24) node {$a:A$};
\draw [white] (24.7,-44.2) circle (3);
\draw (24.7,-44.2) node {$y_{t_2}:\mbox{ }A$};
\draw [white] (40,-44.2) circle (3);
\draw (40,-44.2) node {$y_{t_2}:\mbox{ }A$};
\draw [white] (40,-33.9) circle (3);
\draw (40,-33.9) node {$b:\mbox{ }A,B$};
\draw [white] (40,-24) circle (3);
\draw (40,-24) node {$a:\mbox{ }A$};
\draw [white] (40,-54.1) circle (3);
\draw (40,-54.1) node {$y_{t_4}:\mbox{ }A$};
\draw [white] (55.7,-24.6) circle (3);
\draw (55.7,-24.6) node {$a:\mbox{ }A$};
\draw [white] (55.7,-34.5) circle (3);
\draw (55.7,-34.5) node {$b:\mbox{ }A,B$};
\draw [white] (55.7,-14.8) circle (3);
\draw (55.7,-14.8) node {$y_{t_4}:\mbox{ }A$};
\draw [white] (11.9,-28.9) circle (3);
\draw [white] (20.5,-28.9) circle (3);
\draw [white] (28.6,-28.8) circle (3);
\draw [white] (36.9,-28.8) circle (3);
\draw [white] (44,-28.8) circle (3);
\draw [white] (52.7,-28.8) circle (3);
\draw [white] (58.6,-29.9) circle (3);
\draw [white] (67.2,-29.9) circle (3);
\draw (67.2,-29.9) node {$\ldots$};
\draw [black] (11.162,-25.868) arc (46.19008:-46.19008:4.686);
\fill [black] (11.16,-25.87) -- (11.39,-26.78) -- (12.09,-26.06);
\draw (13.1,-29.25) node [right] {$R$};
\draw [black] (5.784,-32.753) arc (-131.32879:-228.67121:4.664);
\fill [black] (5.78,-32.75) -- (5.51,-31.85) -- (4.85,-32.6);
\draw (3.7,-29.25) node [left] {$R$};
\draw [black] (8.5,-21.6) -- (8.5,-17.8);
\fill [black] (8.5,-17.8) -- (8,-18.6) -- (9,-18.6);
\draw (9,-19.7) node [right] {$R$};
\draw [black] (8.5,-11.8) -- (8.5,-8.4);
\fill [black] (8.5,-8.4) -- (8,-9.2) -- (9,-9.2);
\draw (9,-10.1) node [right] {$R$};
\draw [black] (27.299,-25.408) arc (44.53872:-44.53872:5.05);
\fill [black] (27.3,-25.41) -- (27.5,-26.33) -- (28.22,-25.63);
\draw (29.25,-28.95) node [right] {$R$};
\draw [black] (22.29,-32.183) arc (-141.88061:-218.11939:5.237);
\fill [black] (22.29,-32.18) -- (22.19,-31.24) -- (21.4,-31.86);
\draw (20.67,-28.95) node [left] {$R$};
\draw [black] (24.7,-36.9) -- (24.7,-41.2);
\fill [black] (24.7,-41.2) -- (25.2,-40.4) -- (24.2,-40.4);
\draw (24.2,-39.05) node [left] {$R$};
\draw [black] (42.676,-25.254) arc (47.68401:-47.68401:4.998);
\fill [black] (42.68,-25.25) -- (42.93,-26.16) -- (43.6,-25.42);
\draw (44.81,-28.95) node [right] {$R$};
\draw [black] (40,-47.2) -- (40,-51.1);
\fill [black] (40,-51.1) -- (40.5,-50.3) -- (39.5,-50.3);
\draw (39.5,-49.15) node [left] {$R$};
\draw [black] (40,-36.9) -- (40,-41.2);
\fill [black] (40,-41.2) -- (40.5,-40.4) -- (39.5,-40.4);
\draw (39.5,-39.05) node [left] {$R$};
\draw [black] (37.553,-32.236) arc (-140.75683:-219.24317:5.195);
\fill [black] (37.55,-32.24) -- (37.43,-31.3) -- (36.66,-31.93);
\draw (35.88,-28.95) node [left] {$R$};
\draw [black] (53.409,-32.624) arc (-145.24527:-214.75473:5.392);
\fill [black] (53.41,-32.62) -- (53.36,-31.68) -- (52.54,-32.25);
\draw (51.95,-29.55) node [left] {$R$};
\draw [black] (58.055,-26.393) arc (36.51301:-36.51301:5.305);
\fill [black] (58.06,-26.39) -- (58.13,-27.33) -- (58.93,-26.74);
\draw (59.6,-29.55) node [right] {$R$};
\draw [black] (55.7,-21.6) -- (55.7,-17.8);
\fill [black] (55.7,-17.8) -- (55.2,-18.6) -- (56.2,-18.6);
\draw (56.2,-19.7) node [right] {$R$};
\draw [red] (14.9,-28.9) -- (17.5,-28.9);
\fill [red] (17.5,-28.9) -- (16.7,-28.4) -- (16.7,-29.4);
\draw [red] (31.6,-28.8) -- (33.9,-28.8);
\fill [red] (33.9,-28.8) -- (33.1,-28.3) -- (33.1,-29.3);
\draw [red] (47,-28.8) -- (49.7,-28.8);
\fill [red] (49.7,-28.8) -- (48.9,-28.3) -- (48.9,-29.3);
\draw [red] (61.6,-29.9) -- (64.2,-29.9);
\fill [red] (64.2,-29.9) -- (63.4,-29.4) -- (63.4,-30.4);
\end{tikzpicture}
\end{center}
\end{example}

The last example show the importance of doing a total merging. We have to prove that our merging algorithm does a total merging:

\begin{proposition}\label{no_more_siblings}
Let $G$ be a factbase that occurs in a chase derivation of the knowledge base $O$. There does not exists a term $t$ and a variable $x$ such that $x$ is mergeable on $t$ in $\Merge(G)$.
\end{proposition}

\begin{proof}
Suppose for a contradiction that there exists a term $t$ and a variable $x$ such that $x$ is mergeable on $t$ in $\Merge(G)$, that is, there exists a term $t'$ and a binary predicate $R$ such that $R(t',x),R(t',t) \in \Merge(G)$. This case can happen only if $x$ became mergeable  after that $x$ has been traited by the merging algorithm. Thus, during the merging, there has been an atomic merging over $t'$. Let $y$ be the variable merged on $t'$ such that $y \prec x$. We note $G^1$ the factbase just before the atomic merging of $y$ over $t'$ and we note $G^2$ the factbase just after the atomic merging. There exists a term $t_0$ and a binary predicate $S$ such that $S(t_0,t'),S(t_0,y) \in G^1$. $G^1$ is the left figure and $G^2$ is the right figure (we do not represent all the graphs):

\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
%\filldraw[color=red!60, fill=red!5, very thick](17,-38) circle (6);
%\filldraw[color=red!60, fill=red!5, very thick](60,-39) circle (6);
%\filldraw[color=red!60, fill=red!5, very thick](10,-11) circle (4);
%\filldraw[color=red!60, fill=red!5, very thick](25,-11) circle (4);
%\filldraw[color=red!60, fill=red!5, very thick](65,-11) circle (4);
%\filldraw[color=red!60, fill=red!5, very thick](54,-11) circle (4);
\draw [white] (17.1,-35.9) circle (3);
\draw (17.1,-35.9) node {$t_0$};
\draw [white] (10.1,-24.1) circle (3);
\draw (10.1,-24.1) node {$t'$};
\draw [white] (24.1,-24.1) circle (3);
\draw (24.1,-24.1) node {$y$};
\draw [white] (24.1,-12.4) circle (3);
\draw (24.1,-12.4) node {$x$};
\draw [white] (10.1,-12.4) circle (3);
\draw (10.1,-12.4) node {$t$};
\draw [white] (30.7,-24.6) circle (3);
\draw [white] (50.4,-24.6) circle (3);
\draw [white] (59.7,-36.8) circle (3);
\draw (59.7,-36.8) node {$t_0$};
\draw [white] (59.7,-25.3) circle (3);
\draw (59.7,-25.3) node {$t'$};
\draw [white] (53.4,-13.2) circle (3);
\draw (53.4,-13.2) node {$t$};
\draw [white] (65.4,-13.2) circle (3);
\draw (65.4,-13.2) node {$x$};
\draw [black] (15.57,-33.32) -- (11.63,-26.68);
\fill [black] (11.63,-26.68) -- (11.61,-27.62) -- (12.47,-27.11);
\draw (14.25,-28.75) node [right] {$S$};
\draw [black] (10.1,-21.1) -- (10.1,-15.4);
\fill [black] (10.1,-15.4) -- (9.6,-16.2) -- (10.6,-16.2);
\draw (10.6,-18.25) node [right] {$R$};
\draw [black] (18.63,-33.32) -- (22.57,-26.68);
\fill [black] (22.57,-26.68) -- (21.73,-27.11) -- (22.59,-27.62);
\draw (21.25,-31.25) node [right] {$S$};
\draw [black] (24.1,-21.1) -- (24.1,-15.4);
\fill [black] (24.1,-15.4) -- (23.6,-16.2) -- (24.6,-16.2);
\draw (24.6,-18.25) node [right] {$R$};
\draw [black] (33.7,-24.6) -- (47.4,-24.6);
\fill [black] (47.4,-24.6) -- (46.6,-24.1) -- (46.6,-25.1);
\draw [black] (59.7,-33.8) -- (59.7,-28.3);
\fill [black] (59.7,-28.3) -- (59.2,-29.1) -- (60.2,-29.1);
\draw (60.2,-31.05) node [right] {$S$};
\draw [black] (58.31,-22.64) -- (54.79,-15.86);
\fill [black] (54.79,-15.86) -- (54.71,-16.8) -- (55.6,-16.34);
\draw (57.24,-18.11) node [right] {$R$};
\draw [black] (60.98,-22.59) -- (64.12,-15.91);
\fill [black] (64.12,-15.91) -- (63.33,-16.42) -- (64.23,-16.85);
\draw (63.26,-20.3) node [right] {$R$};
\end{tikzpicture}
\end{center}

We have $t_0 \prec t' \prec t$ and $t_0 \prec y \prec x$ so $x$ should have been treated by the algorithm after the merging of $t'$ and $y$ so the algorithm will merge $x$ on $t$: contradiction. 
\end{proof}

We want now prove that a merging computes a core:

\begin{proposition} \label{core}
For a factbase $G$ obtained by applying some Horn-$\mathcal{ALC}$ axioms on $O$, $\Merge(G)$ is a core.
\end{proposition}

\begin{proof}
%\item The $\mathcal{ALC}$-pruning algorithm only take off facts of the factbase. Consequently, $\textit{prune}(G) \subseteq G$.
%\item We consider the homorphism $h:G \to \textit{prune}(G)$ created during the $\mathcal{ALC}$-pruning algorithm. For $x \in \Vars(G)$, suppose that $h(x) \neq x$. According to the $\mathcal{ALC}$-pruning algorithm, $x$ has been erased \todo{Ã  prÃ©ciser}. So $x \notin \Vars(\textit{prune}(G))$. So ${h}_{|\textit{Prune}(G)}=id_{|\textit{Prune}(G)}$. We have shown that $h$ is a retract so $\textit{prune}(G)$ is a retract of $G$.
Suppose for a contradiction that $\Merge(G)$ is not a core. There exists $G' \subsetneq \Merge(G)$ such that $G'$ is a retract of $\Merge(G)$. By Proposition \cite{retract}, there exists then a retractation $h$ from $\Merge(G)$ to $G'$, $var(\Merge(G))\setminus var(G') \neq \emptyset$. Let $x$ be a $\prec$-minimal variable of this set. $x$ is a variable, so has been introduced by the chase due to the axiom 3. So there exists a term $t$ such that $t \prec x$. 
\begin{itemize}
\item We have $\Preds^2_{\Merge(G)}(t,x) \neq \emptyset$. By $\prec$-minimality of $x$, $t \in \Vars(G')$. So, as $h$ is a retractation: $h(t) = t$, so for $R \in \Preds^2_{\Merge(G)}(t,x)$, $h(R(t,x)) = R(t,h(x)) \in \Merge(G)$ and so $R \in \Preds^2_{\Merge(G)}(t,h(x))$. Thus $\Preds^2_{\Merge(G)}(t,x) \subseteq \Preds^2_{\Merge(G)}(t,h(x))$ and $t \prec h(x)$.
\item $x \notin G'$ and $h(x) \in G'$ so $h(x) \neq x$. 
\item Let $A \in \Preds^1_{\Merge(G)}(x)$. $h(A(x)) \in \Merge(G)$ so $A(h(x)) \in \Merge(G)$ so $\Preds^1_{\Merge(G)}(x) \subseteq \Preds^1_{\Merge(G)}(h(x))$. 
\end{itemize}
Consequently, $x$ is mergeable on $h(x)$ in $\Merge(G)$. So, by proposition \ref{no_more_siblings}, the merging should have suppress $x$ or $h(x)$, so $x \notin \Merge(G)$ or $h(x) \notin \Merge(G)$: contradiction. So $\Merge(G)$ is a core.
\end{proof}	

$\Merge(G)$ is a core but not necessarily the core of $G$.


%\begin{definition}
%$tr = (\alpha,\sigma, \hat \sigma)$ is a \emph{stupid trigger} if $(\alpha,\sigma)$ is an oblivious trigger, and if $\hat \sigma$ extends $\sigma$ and is defined on $\Vars(\textit{Head}(\alpha))$. The factbase $\Appl(F,tr)=F \cup \hat \sigma(\textit{Head}(\alpha))$ is called an \emph{application} on the factbase $F$ through the stupid trigger $tr = (\alpha,\sigma, \hat \sigma)$. A \emph{stupid derivation} from a knowledge base $O= (F,R)$ is a (possibly infinite) sequence $D=F_0,tr_1,F_1,tr_2,F_2,\ldots$ where $(F_i)_{i \in \N}$ are factbases, $tr_i$ are stupid triggers, $F_0 = F$, and for $i >0$, $F_{i}= \Appl(F_{i-1},tr_i)$ is obtained by an application. The stupid derivation $D=F_0,t_1,F_1,t_2,F_2,\ldots$ is \emph{fair} if for every $i$ and every stupid trigger $tr = (\alpha,\sigma, \hat \sigma)$ applicable on $F_i$, there exists $k \geq i$ such that there exists a stupid trigger $tr' = (\alpha,\sigma, \hat \sigma')$ that verified $\Appl(F_{k},tr') = F_k$. A \emph{stupid chase} for a knowledge base $O= (F,R)$ is a fair stupid derivation $D=F_0,tr_1,F_1,tr_2,F_2,\ldots$ $F_0 \subseteq F_1 \subseteq F_2 \subseteq \ldots$ so we can pose \emph{$\textit{Stp(O)}$} = $\cup_{i \in \N}F_i$.
%We say that the stupid chase \emph{terminates} if $\textit{Stp(O)}$ is finite.
%\end{definition}


\subsection{Corectness}

To prove that the merge chase is a correct algorithm, we have to show that:
\begin{itemize}
\item It preserves the universality.
\item A merge step computes a core.
\end{itemize}

To simplify the proofs, we will allow us to use the same triggers. It will not really change the result because we can just add redundances and it preserves the terminaison. We cannot use anymore our definition of application so we redefine it. A naive trigger is a triple $t=(\alpha,\sigma,\hat \sigma)$ where $(\alpha,\sigma)$ is an oblivious trigger and  $\hat \sigma$ is a subsitution that extends $\sigma$ over $\Vars(\textit{Head}(\alpha))$. The factbase $\Appl(F,t)=F \cup \hat \sigma(\textit{Head}(\alpha))$ is an application on the factbase $F$ through the trigger $t$.

\begin{proposition} \label{step1}
Let $D = F_0,trig_1,F_1,\ldots, trig_m,F_m$ be a chase derivation of the knowledge base $O$. Let $x$ be mergeable on $t$ in $F_m$. Let $h$ be a substitution defined on $\Vars(\Tree_{F_m}(x))$ such that $h(x) =t$ and for $y \neq x$, $h(y)$ is a fresh variable. There exists an oblivious chase derivation $D' = F_0,trig_1,F_1,\ldots,trig_k,F_k$ of $O$ prolonging $D$ such that $F_k = F_m \cup h(\Tree_{F_m}(x))$ . We pose \emph{$F_{\Fut(F_m,t,x)}$}$=F_k$ and \emph{$h_{\Fut(F_m,t,x)}$}$ = h$.
\end{proposition}

Graphically, if we note $A=\Tree_{F_m}(t)$ and $B=\Tree_{F_m}(x)$, then we want do an oblivious derivation from the left factbase to the right factbase:


\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [white] (20,-48.6) circle (3);
\draw [white] (10.7,-40.8) circle (3);
\draw (10.7,-40.8) node {$t$};
\draw[orange, ultra thick] (10.7,-38) -- (5,-25) -- (15,-25) -- cycle;
\draw [white] (28.1,-40.8) circle (3);
\draw (28.1,-40.8) node {$x$};
\draw[blue, ultra thick] (28.1,-38) -- (23,-25) -- (33,-25) -- cycle;
\draw [white] (10,-29.2) circle (3);
\draw (10,-29.2) node {$A$};
\draw [white] (28.1,-29.2) circle (3);
\draw (28.1,-29.2) node {$B$};
\draw [white] (56.1,-48.6) circle (3);
\draw [white] (47.6,-40.8) circle (3);
\draw (47.6,-40.8) node {$t$};
\draw[orange, ultra thick] (48,-38) -- (37,-25) -- (47,-25) -- cycle;
\draw[blue, ultra thick] (48,-38) -- (49,-25) -- (59,-25) -- cycle;
\draw [white] (64.5,-40.8) circle (3);
\draw (64.5,-40.8) node {$x$};
\draw[blue, ultra thick] (64.5,-38) -- (60,-25) -- (70,-25) -- cycle;
\draw (44,-30.1) node {$A$};
\draw (52.5,-30.1) node {$h(B)$};
\draw [white] (65.5,-30.7) circle (3);
\draw (65.5,-30.7) node {$B$};
\draw [white] (30.8,-46.4) circle (3);
\draw [white] (45.5,-46.4) circle (3);
\draw [black] (17.7,-46.67) -- (13,-42.73);
\fill [black] (13,-42.73) -- (13.29,-43.63) -- (13.93,-42.86);
\draw [black] (22.16,-46.52) -- (25.94,-42.88);
\fill [black] (25.94,-42.88) -- (25.02,-43.08) -- (25.71,-43.8);
\draw [black,dashed] (12.931,-38.807) arc (124.28182:55.71818:11.484);
\fill [black] (12.93,-38.81) -- (13.87,-38.77) -- (13.31,-37.94);
\draw [black] (53.89,-46.57) -- (49.81,-42.83);
\fill [black] (49.81,-42.83) -- (50.06,-43.74) -- (50.74,-43);
\draw [black] (58.3,-46.56) -- (62.3,-42.84);
\fill [black] (62.3,-42.84) -- (61.38,-43.02) -- (62.06,-43.75);
\draw [black,dashed] (49.831,-38.809) arc (124.01582:55.98418:11.116);
\fill [black] (49.83,-38.81) -- (50.77,-38.78) -- (50.21,-37.95);
\draw [black] (33.8,-46.4) -- (42.5,-46.4);
\fill [black] (42.5,-46.4) -- (41.7,-45.9) -- (41.7,-46.9);
\end{tikzpicture}
\end{center}

To prove the result, we will look all the triggers dealing with the successor of $x$ and apply them on the successor of $t$ even if the triggers has already been applied.

\begin{proof}
Let $tr_1 = (\alpha_1,\sigma_1, \hat \sigma_1),\ldots, tr_n =(\alpha_n,\sigma_n, \hat \sigma_n)$ be all the oblivious triggers in $\{trig_1,\ldots,trig_m\}$ such that
\begin{itemize}
\item the range of each $\hat \sigma_i$ contains at least one $\prec$-sucessor of $x$
\item if $tr_i = trig_r$ and $tr_j =trig_l$, then $i <j$ implies $r<l$ (that is, $tr_1,\ldots,tr_n$ are oredered by application time).
\end{itemize} 
We note $tr_1'=(\alpha_1,\sigma_1',\hat \sigma_1'),\ldots,tr_n' = (\alpha_n,\sigma_n', \hat \sigma_n')$ where $\sigma_i' = h \circ \sigma_i$ and $\hat \sigma_i' = h \circ \hat \sigma_i$. We pose $F_{m+1} = \Appl(F_m,tr_1'),\ldots, F_{m+n} =\Appl(F_{m+n-1},tr_n')$ %and we pose $B_i' = \sigma_1'^s(Head(\alpha_1) \cup \ldots \cup \sigma_i'^s(Head(\alpha_i)$

We show by induction on $i \in \{0,\ldots, n\},H(i)$: the sequence $D_i = D,tr_1',F_{m+1},\ldots, tr_i',F_{m+i}$ is an oblivious derivation. 

For i = 0, $D_0 = D$ is an oblivious derivation, so $H(0)$ is true.

Suppose that $H(i-1)$ is true for $i \in \{1,\ldots,n\}$. Depending on the form of the rule $\alpha_i$, there exists four different cases:
	\begin{itemize}
	\item First case $\alpha_i$ is of the form $A(u) \rightarrow \exists v.R(u,v) \wedge B(v)$. We have $A(\sigma_i(u)) \in F_m$.
		\begin{itemize}
		\item If $\sigma_i(u) = x$, then $A(x) \in F_m$. As $t$ is a strong sibling of $x$ in $F_m$, $A(t) \in F_m$. So $A(\sigma_i'(u)) \in F_{m+i-1}$ since $\sigma_i'(u) = t$.  
		\item If $x \prec^+ \sigma_i(u)$, then the fact $A(\sigma_i(u)))$ has been introduced by an oblivious trigger in $\{tr_1,\ldots,tr_{i-1}\}$. We have then by induction hypothesis, $A(\sigma_i'(u)) \in F_{m+i-1)}$.
		\end{itemize}
Therefore $tr_{i}'$ is an oblivious trigger on $F_{m+i-1}$. So $H(i)$ is true.

	\item Second case $\alpha_i$ is of the form $A_1(u) \wedge A_2(u) \rightarrow B(u)$. We have $x \prec^+ \sigma_i(u)$. The facts $A_1(\sigma_i(u))$ and $A_2(\sigma_i(u))$ have been introduced by two oblivious trigger in $\{tr_1,\ldots,tr_{i-1}\}$. So by induction hypothesis,$A_1(h(\sigma_i(u))),A_2(h(\sigma_i(u))) \in F_{m+i-1}$. So $tr_{i}'$ is an oblivious trigger on $F_{m+i-1}$. Consequently, $H(i)$ is true.

\item Third case $\alpha_i$ is of the form $A(u) \wedge R(u,v) \rightarrow B(v)$.
	\begin{itemize}
		\item If $\sigma_i(u) = x$, then $A(x) \in F_m$. As $t$ is a strong sibling of $x$ in $F_m$, $A(t)\in F_m$. $A(\sigma_i'(u)) \in F_{m+i-1}$.
		\item If $x \prec^+ \sigma_i(u)$, then the fact $A(\sigma_i(u))$ has been introduced by an oblivious trigger in $\{tr_1,\ldots,tr_{i-1}\}$. So, by induction hypothesis, $A(\sigma_i'(u)) \in F_{m+i-1}$. 
		\end{itemize}
the fact $R(\sigma_i(u),\sigma_i(v))$ has been introduced by an oblivious trigger in $\{tr_1,\ldots,tr_{i-1}\}$.So by induction hypothesis, $R(\sigma_i'(u),\sigma_i(v)) \in F_{m+i-1}$. 

Therefore, the facts $A(\sigma_i(x))$ and $R(\sigma_i(u),\sigma_i(v))$ are in $ F_{m+i-1}$. So $tr_{i}'$ is an oblivious trigger on $F_{m+i-1}$. So H(i) is true.
\item Fourth case $\alpha_i$ is of the form $R(u,v) \wedge B(v) \rightarrow A(u)$.

The facts $R(\sigma_i(u),\sigma_i(v)),B(\sigma_i(v))$ has been introduced by an oblivious trigger in $\{tr_1,\ldots,tr_{i-1}\}$. So, by induction hypothesis, the facts $A(\sigma_i(x))$ and $R(\sigma_i(u),\sigma_i(v))$ are in $ F_{m+i-1}$. So $tr_{i}'$ is an oblivious trigger on $F_{m+i}$. We conclude that $H(i)$ is true.
	\end{itemize}
	
We have proved the heredity. So, $D_n$ is the oblivious derivation that we was looking for. We have $F_{m+n} = F_m \cup h_n(\Tree_{F_m}(x))$.

\end{proof}


\begin{proposition}
Let $D = F_0,trig_1,F_1,\ldots, trig_m,F_m$ be an oblivious chase derivation of the knowledge base $O$. Assume that $x$ is mergeable on $t$ in $F_m$.  
$F_{\Fut(F_m,t,x)}$ is equivalent to the atomic merging of $x$ over $t$ in $F_m$.
\end{proposition}

\begin{proof}
We note $F'$ the atomic merging of $x$ over $t$ in $F_m$ and we pose $h = h_{\Fut(F_m,t,x)}$. By the Proposition \ref{step1}, $F_{\Fut(F_m,t,x)}= F_m \cup h(\Tree_{F_m}(x))$. We have that $h$ is a bijection on $\Vars(\Tree_{F_m}(x)) - \{x\}$ so $h^{-1}$ is well defined on this set. We pose: 
\begin{align*}
h_1:&\ \Vars(F_{\Fut(F_m,t,x)}) \to \Terms(F') \\
&y \mapsto t  \text{ if }y=x \\
&y \mapsto h^{-1}(y) \text{ if }y \neq x \wedge\ y \in \Vars(h(\Tree_{F_m}(x)))\\
&y \mapsto y \text{ otherwise}
\end{align*} 
and
\begin{align*}
h_2: \Vars(F') &\to \Terms(F_{\Fut(F_m,t,x)}) \\
y &\mapsto h(y) \text{ if } y \in \Vars(\Tree_{F_m}(x)) \\
y &\mapsto y \text{ otherwise}
\end{align*}

$h_1$ is a homomorphism from $F_{\Fut(F_m,t,x)}$ to $F'$ and $h_2$ is a homomorphism from $F'$ to  $F_{\Fut(F_m,t,x)}$. \todo{inserer graphique}


\end{proof}

We have proved that the atomic merge chase preserves the universality, therefore:

\begin{proposition}
The atomic merge chase and the merge chase computes an universal model when they terminate.
\end{proposition}

By Proposition \cite{core}, the merge chase computes a core, therefore, we can use the the results of the paper \cite{core_chase} to have the following theorem:

\begin{theorem}
The merge chase computes an universal model if and only if there exists an universal model.
\end{theorem}






\subsection{Generalisation}

\begin{definition}[Horn-$\mathcal{ALCH}$ and Horn-$\mathcal{ALCHI}$ axioms]
A \emph{Horn-$\mathcal{ALCH}$ axiom} is either a Horn-$\mathcal{ALC}$ axiom or an existential rule of the form:
\begin{align}
R_1(x,y) \wedge R_2(x,y) \wedge \ldots \wedge R_n(x,y) \rightarrow S(x,y)
\end{align}
A \emph{Horn-$\mathcal{ALCHI}$ axiom} is either a Horn-$\mathcal{ALCH}$ axiom or an existential rule of the form:
\begin{align}
R_1(x,y) \wedge R_2(x,y) \wedge \ldots \wedge R_n(x,y) \rightarrow S(y,x)
\end{align}

\end{definition}

\subsubsection{Horn-$\mathcal{ALCH}$}

We fix $O=(R,F)$ a knowledge base for this section where $R$ is a Horn-$\mathcal{ALC}$ rule set and F is a ground factbase with predicates of arity one or two. We have to modify the merge chase because it doesn't work anymore:

\begin{example}
If we have the knowledge base $O=(R,F)$ where $F =  \{A(a)\}$ and the rules are :
\begin{align*}
A(x) &\rightarrow \exists y. S(x,y) \wedge B(y) \\
A(x) &\rightarrow \exists y. T(x,y) \wedge B(y) \\
S(x,y) &\rightarrow R(x,y) \\
T(x,y) &\rightarrow R(x,y) \\
\end{align*}
By applying the rules one, two, three and then four, we have the factbase $G$:

\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [white] (39.8,-38.8) circle (3);
\draw (39.8,-38.8) node {$a:\mbox{ }A$};
\draw [white] (31.4,-27.4) circle (3);
\draw (31.4,-27.4) node {$x:\mbox{ }B$};
\draw [white] (49,-27.4) circle (3);
\draw (49,-27.4) node {$y:\mbox{ }B$};
\draw [black] (38.02,-36.38) -- (33.18,-29.82);
\fill [black] (33.18,-29.82) -- (33.25,-30.76) -- (34.06,-30.16);
\draw (36.18,-31.71) node [right] {$R,S$};
\draw [black] (41.68,-36.47) -- (47.12,-29.73);
\fill [black] (47.12,-29.73) -- (46.22,-30.04) -- (47,-30.67);
\draw (44.96,-34.53) node [right] {$R,T$};
\end{tikzpicture}
\end{center}

Then, when we apply a merging:

\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [white] (39.8,-38.8) circle (3);
\draw (39.8,-38.8) node {$a:\mbox{ }A$};
\draw [white] (39.8,-26.8) circle (3);
\draw (39.8,-26.8) node {$x:\mbox{ }B$};
\draw [black] (39.8,-35.8) -- (39.8,-29.8);
\fill [black] (39.8,-29.8) -- (39.3,-30.6) -- (40.3,-30.6);
\draw (40.3,-32.8) node [right] {$R,S,T$};
\end{tikzpicture}
\end{center}

The merging is bad because this factbase is not a universal model of $O$.

\end{example}

We keep the same relation $\prec$. It is still a strict partial order over the set of variables.





\bibliographystyle{plain}
\bibliography{sample}


\end{document}









tree-like structure 

\begin{definition}[Entailment]
A factbase F \emph{entails} a factbase F' (often noted F $\models F'$) if for all model M de T, M is a model of F'. 
\end{definition}

Let $\prec$ be a strict total order over the set of variables. A variable x occuring in a factbase F is \emph{superfluous} if there exists two variables y and z such that:
\begin{itemize}
\item For all unary predicate P such that $P(x) \in F$, $P(y) \in F$.
\item For all binary predicate R such that $R(z,x) \in F$, $R(z,y) \in F$
\end{itemize}
The \emph{pruning sequence} of a factbase F is the sequence $(F_i)_{i \in \{1,\ldots,n\}}$ of factbases where:
\begin{itemize}
\item $F_1 = F$;
\item for all $i \in \{2,\ldots,n\}$, $F_i$ is the set obtained when we remove every fact of $F_{i-1}$  that contains the smallest superfluous variable (smallest according to $\prec$).
\item $F_n$ does not contain any superfluous variables.
\end{itemize}
We pose \emph{prune(F)} = $F_n$.